# Втора лабораториска вежба по Софтверско инженерство
<h2> &nbsp; Зорица Коцева, бр. на индекс 185043</h2>

<h3>Група на код:</h3>
<p> &nbsp; &nbsp; Ја добив и работев на групата код 4</p>

### Control Flow Graph

<img src="./Testing CFG and code nodes.png">
<br>
<hr>

### Цикломатска комплексност
Цикломатската комплексност на дадениот код според група 4 е 10 , истата ја добив преку формулата E-V+2, каде што Е ни преставува бројот на ребра, а V бројот на темиња. Во случајoв имаме Е= 27 и V=19 . Доколку се заменат вредностите добиваме 27-19+2=10, па цикломатската комплексност е всушност и бројот на региони. Односно попрегледно ако претставиме:

<ul>
  •	Е - број на ребра во Control Flow Graph<br>
  •	V – број на темиња во Control Flow Graph<br>
  E-V+2= комплексност
 </ul>
Цикломатска комплексност => број на јазли - број на темиња + 2, 27-19+2=10</br>
Цикломатска комплексност => број на предикатни јазли + 1</br>
Цикломатска комплексност => број на региони -> 10</br>


#### Кон каде не води графот, како е добиен според функцијата?

<p align="justify">
На почеток Јазел 1,2 е влезот во неа со предавање аргументи за User и List од корисници(опционално), јазелот  2 е декларирање и дефинирање на променливата specialCharacters која ги содржи сите катрактери кои се дозволени за користење при креирањето на лозинката. Овие два јазли се извршуваат секогаш при секој повик на функцијата function и се извршуваат еден по друг секогаш така што се поставени во еден јазол.</br></br>

Јазол 3 е проверка дали User има внесено параметар што не е null или празен стринг, односно да не постои. Доколку не е исполнето, директно функцијата враќа false кон јазел 18(denied) и престанува да се извршува водејќи кон јазел 19(done).
Доколку условот е исполнет оди во јазол 4 каде се проверува дали корисникот ги внел корисничкото име и лозинката без притоа да се оставени празни, null. Доколку не е исполнето, директно функцијата враќа false кон јазел 18(denied) и престанува да се извршува водејќи кон јазел 19(done).</br></br>

Наредно ако програмата ги има исполнето условите до тука одиме во јазлите: 5 се дефинира лозинката од корисникот која се превзема и поставува во променлива password, 6 дефинирање на passwordLower и притоа дефинираната превземана лозинка ја правиме во малечки букви, и во јазел 7 е услов дека лозинката која била внесена да нема мали букви и должината да биде подолга или точно осум-8 карактери. Доколку не е исполнето, директно функцијата враќа false кон јазел 18(denied) и престанува да се извршува водејќи кон јазел 19(done).
Ако претходниот услов 7 е исполнет продолжуваме да дефинираме нов јазел 8 со Boolean променливи на почеток претставени на false бидејќи сѐ уште нема проверки и ништо не е познато за тоа што ќе треба лозинката да ја проверуваме дали содржи цифра, голема буква и специјален карактер од понудените погоре дефинирани карактери во дамата променлива и јазел 2.</br></br>

Јазелот 9 е „расцепкан“ на подјазли 9.1, 9.2,  9.3 секој соодветно секвенцијално претставен за циклусот за i=0, i<password.length(), i++ за полесно да итерираме и да се движиме и низ графот и низ самата функција. Со ова итерација по итерација се движиме низ карактерите и соодветно ако е цифра од проверка во јазол 10, променливата која треба да се промени од непронајдена треба за цифри да биде digit=true, доколку не одиме на следен јазел 12 за проверка дали карактерот на моменталната позиција е голема буква внесена според корисничкиот внес на лозинка (ова е важно), па променливата која треба да се промени од непронајдена треба за голема буква да биде upper=true во јазел 13, доколку не одиме на следен јазел 14 каде проверуваме дали карактерот на моменталната позиција е специјален знак/карактер и доколку е треба за специјалниот карактер да биде special=true во јазел 15. </br></br>

Откако овие проверки ќе се извршат додека има карактери во лозинката, одиме во следниот јазел услов 16 да провериме дали сите поставени boolean променливи имаат вредност true. Доколку се е во ред исполнето, се продолжува во јазел 17 и знаеме дека внесената лозинка е точна и програмата се извршува со тоа што одиме во јазел 19 колку да знаеме и да се забележи дека се излегува од функцијата во програмата. Доколку има некоја вредност во трите променливи за кои критериумот не се исполнува, односно и трите услови не се задоволени, од јазел 16 се оди кон јазел 18 дека не е изполнето се, и од таму програмата завршува водејќи не кон јазел 19.</br></br>
</p>
<br>
                 
 ### Тест случаи според критериумот Every Statement
Методата на тестирање налага да се генерираат test cases со кои секоја наредба посебно ќе се истестира. Вака секој statement од кодот ќе може да се истестира </br>

<ol>
  <li>* user != null : постои/имаме предадено корисник <br>
    &nbsp; &#9903; поврзаност на линија код со јазел: 1,2,3,4,18<br> 
</li><br>
  <li>* user.getUsername()!=null && user.getPassword()!=null: корисникот внел корисничко име, имаме предадено податоци за корисникот како      username и password<br>
    &nbsp; &#9903; поврзаност на линија код со јазел: 3,4,5,18<br>
</li><br>   
  <li>* !passwordLower.contains(user.getUsername().toLowerCase()) && password.length()>=8: ако корисникот внел големи букви и должината на лозинката е задоволива со што е подолга или точно 8 карактери<br>
    &nbsp; &#9903; поврзаност на линија код со јазел: 6,7,8,18<br>
</li><br>    
  <li>* Character.isDigit(password.charAt(i)): корисникот во лозинката вметнал цифра<br>
    &nbsp; &#9903; поврзаност на линија код со јазел: 9.2, 11, 12<br>
</li><br>   
  <li>* Character.isUpperCase(password.charAt(i)): корисникот вметнал голема буква на позицијата<br>
    &nbsp; &#9903; поврзаност на линија код со јазел:  10, 11, 13, 14<br>
</li><br>   
  <li>* 	specialCharacters.contains(String.valueOf(password.charAt(i))): корисникот вметнал еден од специјалните карактери на позицијата<br>
    &nbsp; &#9903; поврзаност на линија код со јазел: 12, 13, 15, 9.3<br>
</li><br>   
  <li>* if (digit && upper && special): трите услови се задоволени од страна на корисникот<br>
    &nbsp; &#9903; поврзаност на линија код со јазел: 9.2, 17, 18<br>
</li><br>   

</ol>  

![Every statement Testing](https://user-images.githubusercontent.com/45801406/84569643-94184f00-ad88-11ea-82a5-ca527638cf5b.png)

</br>

### Тест случаи според критериумот Every path
Методата за овој вид на тестирање е темелна бидејќи ваквиот начин на тестирање користи секвенца, односно има единствена секвенца од програмски јазли и со тоа се извршуваат со дадениот test case за кодот.Се разгледуваат сите можни патеки од почетокот до јазлите кои го означуваат и крајот на функцијата. 

Возможните патеки би дошле до крајниот јазел, односно до завршувањето на функцијата

![Every Path Testing](https://user-images.githubusercontent.com/45801406/84570186-0a6a8080-ad8c-11ea-80a5-bdb447f6fa41.png)

</br>

### Објаснување на напишаните unit tests

<p> &#9989; Every Statement unit tests на функцијата за проверка на лозинка: </p>
<br>  
За да се случи тест случајот да е true и да испадне лозинката точна, би имале само еден случај кој ги задоволува сите три услови: да има голема буква, да содржи цифра и специјален карактер, со што и како подуслов за должината на лозинката е и да биде поголема или точно да изнесува 8.<br>
Со самото тоа што веќе знаеме што точно ни бара функцијата во програмата, ќе го поставиме тест случај кој што ќе ги опфаќа сите критериуми за функцијата на крај да го даде посакуваното точно решение. Па после според самите услови, чекор по чекор можеме да сознаеме кои ќе бидат можните исходи задачата да не го даде она што функцијата всушност и го бара. <br>
Затоа, jUnit тестовите најмногу ги правиме за да може програмата да ги детектира и погрешните внесени параметри, односно предадени аргументи кои придонесуваат кон неточен излез или погрешно нецелосно извршена програма.<br>
Тоа значи дека ќе претпоставиме што би можел одреден корисник да внесе за дадената функција, па според тоа ќе предадеме параметри соодветни со претпоставката за сите да можат да се истестираат со Every Statement методата за тестирање код.
<br>
 <p>&nbsp; &#128187; Извадок примери од неколку линии тест код од целата функција наменета за Every Statement testing:</p>
  <br>
  
```python

@Test
public void EveryStatement() {
    System.out.println("Testing the functionality of given function");


user = new User("Zorica","*Z#$1999","zorica.koceva@students.finki.ukim.mk");
assertTrue("matching",testing.function(user,null));
assertEquals(true,testing.function(user,null));

/* 
in the test below, password doesn't fit because there are lowercases and doesn't contain special character. Also there are not enough
characters, the length is less or equal than 8 characters.    
*/
user=new User("Zorica","*Zorica","zorica.koceva@students.finki.ukim.mk");
assertFalse("password doesn't contain number, found lower case, less then 8 characters",testing.function(user,null));

// firstly password is only 4 characters, will not enter in after node 7 in if piece of code.. also contain only digits but will not check if there are digit, uppercase and special character
user=new User("Zorica","1999","zorica.koceva@students.finki.ukim.mk");
assertFalse(user.getPassword().contains(specialCharacters) && user.getPassword().contains(upperCase) && user.getPassword().length()>=8);
assertFalse("password contain only digits, less or equal than 8",testing.function(user,null));

user=new User("Zorica","!%^#*$","zorica.koceva@students.finki.ukim.mk");
assertFalse(user.getPassword().contains(digit) && user.getPassword().contains(upperCase) && user.getPassword().length()>=8);
assertFalse("password contain only special characters, less or equal than 8",testing.function(user,null));
} 
```

<br>
  <p> &#9989; Every Path unit tests на функцијата за проверка на лозинка: </p>
  <br>
За да ја добиеме точната лозинка, односно според барањата за да може лозинката да биде точна од програмата задоволувајќи ги условите има само една патека која се извршува по одредениот редослед на јазлите за да врати точно или: return true. 
<br>
Од графот се бираат патеки и на тој начин, преведувајќи ги со кодот, преку различни комбинации наоѓаме соодветен пример кој ќе ни го даде самата патека.
Потребно е да се предаде корисник со листа корисници (и/или само корисник, бидејќи во самата функција во програмата корисникот е тој кој што се тестира со внесените параметри). Текот на извршување на програмата низ јазлите е следен:
<br>

```diff
+ 1,2<–>3<->4<->5<->6<->7<->8<->9.1<->9.2<->10<->11<->12<->13<->14<->15<-> 9.3<->9.2<->16<->17<->19
```

<br>
Да појасниме дека патеката се случува само доколку се поминат овие чекори според некој влезен аргумент од корисник, на пример: секако ќе дефинирме дека за да можеме да имаме „карактеристична“лозинка потребно е да поставиме кои ќе ни бидат дозволени карактери за да можат да бидат искористени како „специјални“, притоа во нареден чекор нема предадено null параметар за корисник или празно оставен string.<br> 
Исто така има внесено корисничко име и предаден параметар лозинка која се става во променлива password па се прават сите букви еднакви во нова променлива passwordLower. Вака променливата поминува низ проверка за тоа дали сега има должина која е доволна за да го помине критериумот кој е поставен дека треба да биде подолга или точно 8 карактери.<br>
Што значи дека се преминува на јазелот каде потребните променливи за проверка на валидноста на лозинката ќе може да се постават дека сега на почеток се false бидејќи сѐ уште не знаеме што има корисникот внесено па треба да провериме. Самиот циклус е поделен на три делови (јазел 9 како .1, .2, .3) за да можеме да изминуваме и да се навраќаме на постапките за изминување на самите итерации кои ќе не движат низ карактерите во самиот код за проверка->стрингот за лозинката која ни е главна во моментов.<br>
Движејќи се од почетниот нулти карактер еден по еден проверуваме најпрво ДАЛИ карактерот на позицијата е цифра, доколку секако е ја поставуваме на true, што значи дека ја менуваме променливата за цифрите од false во пронајдена true, ако не пак потоа истото за ДАЛИ карактерот на позицијата е голема буква, доколку секако е ја поставуваме на true, што значи дека ја менуваме променливата за големите букви од false во пронајдена true или пак значи дека треба да биде ДАЛИ карактерот на позицијата е специјален знак, доколку секако е ја поставуваме на true, што значи дека ја менуваме променливата за специјалните знаци од false во пронајдена true. Вака едно од овие да е пронајдена оди низ целиот циклус се додека не дојдеме до последниот карактер и секако со пронајдените одиме во следниот услов да провериме дека сите ги имаме критериуми исполнето за цифра, голема буква и специјален знак, па ни враќа прифатено и завршува програмата.
<br><br>

#### ! Како до невозможна патека !
Ако за лозинката се исполнети условите кои ни се потребни за таа да биде валидна, сите проверки се изминати и очекуваме да помине излезот да ни биде true, за тоа содржи број, голема буква и специјален знак, кај јазелот за делот не е можно на крај да излезе кај false и да не ни дозволи пример да се најавиме на некоја форма за апликација падне на условот if (digit && upper && special).
Тоа значи дека од почетниот јазел ако одиме до циклусот каде ќе се изминуваат итеративно карактерите, проверувајќи низ условите за цифра, голема вуква и карактер се до последната каде трите на крај ќе ни дадат true (барем така знаеме), нема да биде можно после проверката да премине на јазелот 18->denied, едноставно не е возможно таков исход кога очекуваме вистинитосна вредност.
<br>
```diff
- 1,2<–>3<->4<->5<->6<->7<->8<->9.1<->9.2<->10<->11<->12<->13<- >14<->15<-> 9.3<->9.2<->16<->18<->19 
```

</br>
<p> &nbsp; &#128187; Извадок примери од неколку линии тест код од целата функција наменета за Every Path testing:</p>
<br>

```python
@Test
Function EveryPath();

//1,2-3-4-5-6-7-8-9.1-9.2-10-11-12-13-14-15-9.3-9.2-16-17-19
User user = new User("Zorica", "*Z#$1999", "zorica.koceva@students.finki.ukim.mk");
//assertTrue("matching", testing.function(user, null));
assertEquals(true, testing.function(user, null));

//1,2-3-4-5-6-7-18-19
user = new User("Zorica", "*Zorica", "zorica.koceva@students.finki.ukim.mk");
assertFalse("password doesn't contain number, found lowercase, less then 8 characters", testing.function(user, null));
assertFalse(user.getPassword().contains(digit) && user.getPassword().contains(upperCase) && user.getPassword().length() >= 8);

//1,2-3-4-5-6-7-8-9.1-9.2-10-12-14-15-9.3-9.2-16-18-19
user = new User("Zorica", "!%^#*$&!", "zorica.koceva@students.finki.ukim.mk");
assertFalse(user.getPassword().contains(digit) && user.getPassword().contains(upperCase));
assertFalse("password contain only special characters", testing.function(user, null));

//1,2–3-4-5-6-7-8-9.1-9.2-10-11-12-13-14-15- 9.3-9.2-16-18-19
/**
 * This is example of impossible path
 *
 * Also it's impossible to miss a digit, upper case or special character and program to enter
 * in contition and give true to function
 */

//1,2-3-4-5-6-7-8-9.1-9.2-10-11-12-14-9.3-9.2-(10-12-13-14-9.3-9.2)-16-17-19
/**
 * Impossible path
 * Here in password is missing special character
 */

```
